<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>«Жизнь» — интерактивный эмулятор + макет страницы</title>
  
  <!--
    ОДИН ФАЙЛ ДЛЯ GITHUB PAGES!
    ---------------------------------
    Этот файл можно положить в корень gh-pages (или в /docs) как index.html.
    Нужен только чистый HTML/CSS/JS — без сборки и зависимостей.

    ЧТО ЗДЕСЬ ЕСТЬ
    1) Большой заголовок слева + эпиграф справа (sticky, с отступом сверху).
    2) Блок эмулятора «Жизни»:
       - Легко вставляемый X0 (см. JS-константу PRESET_X0 ниже)
       - Кнопки Старт/Пауза/Сброс, кнопка «Доп. настройки»
       - Скрываемая панель настроек (T, задержка) с плавным раскрытием
       - Кликабельное поле для редактирования X0 (при остановленной симуляции)
    3) Четыре текстовых блока (заголовок, основной текст, места под картинки)
    4) Кнопка «Вернуться наверх» с плавной прокруткой

    ДИЗАЙН
    Пастельная палитра, нежные анимации, «облачный» фон.

    ПАЛИТРА (из задания)
      A — основной цвет текста: #281E30
      Б — #98768E (акцент-текст/обводки)
      В — #D3B8C5 (акцент светлый)
      Г — #F6D4CF (градиентная заливка 1)
      Д — #D8928B (градиентная заливка 2)

    ДОСТУПНОСТЬ
    — Уважение prefers-reduced-motion (минимум анимаций при необходимости).
  -->

  <style>
    :root{
      /* Палитра */
      --c-text: #281E30;      /* A */
      --c-accent-1: #98768E;  /* Б */
      --c-accent-2: #D3B8C5;  /* В */
      --c-grad-1: #F6D4CF;    /* Г */
      --c-grad-2: #D8928B;    /* Д */

      /* Общие размеры/радиусы/тени */
      --radius: 16px;
      --radius-sm: 12px;
      --shadow-sm: 0 6px 24px rgba(40, 30, 48, 0.08);
      --shadow-md: 0 10px 34px rgba(40, 30, 48, 0.12);

      /* Скорости анимаций */
      --t-fast: 120ms;
      --t-med: 240ms;
      --t-slow: 400ms;
    }

    /* Фон страницы — «облака» + градиент Б→В */
    body{
      margin: 0;
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Inter, system-ui, Arial, "DejaVu Sans", "Noto Sans", sans-serif;
      color: var(--c-text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(255,255,255,0.85), rgba(255,255,255,0) 60%),
        radial-gradient(1000px 500px at 80% 30%, rgba(255,255,255,0.75), rgba(255,255,255,0) 55%),
        linear-gradient(180deg, var(--c-accent-1), var(--c-accent-2));
      background-attachment: fixed;
      line-height: 1.6;
      scroll-behavior: smooth; /* плавная прокрутка */
    }

    .container{ width: min(1100px, 92vw); margin: 40px auto 100px auto; }

    /* Верхняя полоса: заголовок слева, эпиграф справа */
    .topbar{ display:flex; flex-wrap:wrap; gap: 20px; align-items:flex-start; }
    .page-title h1{ margin: 0; font-size: clamp(28px, 4.6vw, 44px); line-height: 1.15; }
    .page-title .subtitle{ margin: 6px 0 0 0; color: var(--c-accent-1); font-size: 16px; opacity: .9; }

    /* Эпиграф (sticky, с отступом сверху), статический текст */
    .epigraph{ position: sticky; top: 24px; margin-left: auto; width: min(520px, 92vw);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.90)),
        linear-gradient(180deg, rgba(246,212,207,0.18), rgba(216,146,139,0.12));
      backdrop-filter: blur(6px);
      border: 1px solid rgba(152,118,142,0.35);
      border-radius: var(--radius); box-shadow: var(--shadow-sm);
      padding: 16px 18px; transition: box-shadow var(--t-med), transform var(--t-med);
    }
    .epigraph:hover{ box-shadow: var(--shadow-md); transform: translateY(-2px); }
    .epigraph h2{ margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: var(--c-accent-1); }
    .epigraph .epigraph-text{ font-size: 16px; margin: 0; white-space: pre-wrap; }
    .epigraph .byline{ margin-top: 6px; font-size: 14px; color: var(--c-accent-1); opacity: .8; text-align: right; }

    /* Блок симулятора «Жизни» */
    .life-card{
      margin-top: 28px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.90)),
        linear-gradient(180deg, rgba(246,212,207,0.18), rgba(216,146,139,0.12));
      border: 1px solid rgba(152,118,142,0.35);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      overflow: hidden;
      transition: box-shadow var(--t-med), transform var(--t-med);
    }
    .life-card:hover{ box-shadow: var(--shadow-md); transform: translateY(-2px); }
    .life-header{ display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between;
      padding: 14px 16px; background:
        linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.75)),
        linear-gradient(180deg, rgba(246,212,207,0.35), rgba(216,146,139,0.22));
      border-bottom: 1px solid rgba(152,118,142,0.35);
    }
    .life-title{ font-size: 18px; font-weight: 600; color: var(--c-accent-1); }

    .controls{ display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .btn{ appearance: none; border: 1px solid rgba(152,118,142,0.45);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.90)),
        linear-gradient(180deg, rgba(246,212,207,0.30), rgba(216,146,139,0.20));
      color: var(--c-text); border-radius: 999px; padding: 10px 14px; font-size: 15px; font-weight: 600;
      cursor: pointer; transition: transform var(--t-fast), box-shadow var(--t-fast), filter var(--t-fast);
      box-shadow: 0 2px 0 rgba(40,30,48,0.08);
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 6px 18px rgba(40,30,48,0.12); }
    .btn:active{ transform: translateY(0); filter: saturate(0.95); }

    .input{ height: 40px; border-radius: 999px; padding: 0 12px; border: 1px solid rgba(152,118,142,0.45);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0.90)),
        linear-gradient(180deg, rgba(246,212,207,0.18), rgba(216,146,139,0.10));
      outline: none; font-size: 15px; color: var(--c-text);
    }
    .label{ font-size: 14px; color: var(--c-accent-1); margin-left: 6px; margin-right: 4px; }

    /* Холст и панель снизу */
    .life-canvas-wrap{ position: relative; background: #fff; }
    .life-canvas{ width: 100%; height: auto; display: block; }
    .life-footer{ display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 12px 16px; border-top: 1px solid rgba(152,118,142,0.35); }
    .muted{ font-size: 14px; color: var(--c-accent-1); }

    /* Панель дополнительных настроек (collapsible) */
    .settings-panel{ overflow: hidden; max-height: 0; opacity: 0; transform: translateY(-4px); padding: 0 16px;
      border-top: 1px solid rgba(152,118,142,0.25);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0.92)),
        linear-gradient(180deg, rgba(246,212,207,0.12), rgba(216,146,139,0.08));
      transition: max-height var(--t-slow) ease, opacity var(--t-med) ease, transform var(--t-med) ease, padding var(--t-med) ease;
    }
    .settings-panel.open{ max-height: 220px; opacity: 1; transform: translateY(0); padding: 12px 16px; }
    .settings-row{ display:flex; flex-wrap:wrap; gap: 8px; align-items:center; }

    /* Четыре текстовых блока */
    .section{ margin-top: 28px; }
    .card{
      background:
        linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.90)),
        linear-gradient(180deg, rgba(246,212,207,0.18), rgba(216,146,139,0.12));
      border: 1px solid rgba(152,118,142,0.35);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      padding: 18px 20px; transition: box-shadow var(--t-med), transform var(--t-med);
    }
    .card:hover{ box-shadow: var(--shadow-md); transform: translateY(-2px); }
    .card h3{ margin: 6px 0 8px 0; font-size: 20px; color: var(--c-text); }
    .card p{ margin: 0 0 12px 0; }

    .image-row{ display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .image-slot{
      height: 140px; border-radius: var(--radius-sm);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.90), rgba(255,255,255,0.86)),
        linear-gradient(180deg, rgba(246,212,207,0.22), rgba(216,146,139,0.14));
      border: 1px dashed rgba(152,118,142,0.55);
      display: grid; place-items: center; color: var(--c-accent-1); font-size: 14px;
      transition: transform var(--t-fast), box-shadow var(--t-fast);
    }
    .image-slot:hover{ transform: translateY(-2px); box-shadow: var(--shadow-sm); }

    /* Кнопка «наверх» */
    .back-top{ position: fixed; right: 20px; bottom: 20px; z-index: 10; opacity: 0; pointer-events: none; transform: translateY(8px);
      transition: opacity var(--t-med), transform var(--t-med);
    }
    .back-top.show{ opacity: 1; pointer-events: all; transform: translateY(0); }

    /* Мягкое появление секций при скролле */
    .reveal{ opacity: 0; transform: translateY(8px); transition: opacity var(--t-slow), transform var(--t-slow); }
    .reveal.revealed{ opacity: 1; transform: translateY(0); }

    /* Уважение prefers-reduced-motion */
    @media (prefers-reduced-motion: reduce){
      *{ transition: none !important; animation: none !important; }
      html{ scroll-behavior: auto; }
    }
      /* Формульные блоки для MathJax */
    .formula-block{ margin: 14px 0; padding: 10px 14px; background: rgba(255,255,255,0.65); border-left: 4px solid rgba(152,118,142,0.45); border-radius: 10px; overflow-x: auto; }
    .img-placeholder{ margin-top: 14px; height: 180px; border-radius: 14px; background:
        linear-gradient(180deg, rgba(255,255,255,0.90), rgba(255,255,255,0.86)),
        linear-gradient(180deg, rgba(246,212,207,0.22), rgba(216,146,139,0.14));
      border: 1px dashed rgba(152,118,142,0.6); display:flex; align-items:center; justify-content:center; color: var(--c-accent-1); font-size: 14px; text-align:center;
    }
</style>
  <!-- MathJax для LaTeX -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$','$'], ['\(','\)']], displayMath: [['$$','$$'], ['\[','\]']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
</head>
<body>
  <div class="container">

    <div class="topbar">
      <div class="page-title reveal" id="title">
        <h1>Жизнь — поздравление</h1>
        <p class="subtitle">интерактивная страница</p>
      </div>

      <!-- ЭПИГРАФ (правый верх, sticky с отступом сверху) -->
      <section class="epigraph reveal" id="epigraph">
        <h2>Эпиграф</h2>
        <div class="epigraph-body">
          <p class="epigraph-text">Тихие узоры — в ячейках «Жизни». И каждая точка — как пожелание.</p>
          <div class="byline">— автор эпиграфа</div>
        </div>
      </section>
    </div>

    <!-- БЛОК: СИМУЛЯТОР ЖИЗНИ -->
    <section class="life-card reveal" id="life">
      <div class="life-header">
        <div class="life-title">Клеточный автомат «Жизнь» — интерактивное поле</div>
        <div class="controls">
          <button class="btn" id="toggleBtn" aria-pressed="false">Старт</button>
          <button class="btn" id="resetBtn">Сброс</button>
          <button class="btn" id="moreBtn">Доп. настройки</button>
        </div>
      </div>

      <div class="settings-panel" id="settingsPanel" aria-hidden="true">
        <div class="settings-row">
          <label class="label" for="tInput">T:</label>
          <input class="input" id="tInput" type="number" min="1" max="50" step="1" value="8" title="Число шагов эволюции" />
          <label class="label" for="delayInput">задержка (мс):</label>
          <input class="input" id="delayInput" type="number" min="100" max="5000" step="100" value="1500" title="Пауза между шагами" />
        </div>
      </div>

      <div class="life-canvas-wrap">
        <!-- Канвас под сетку. Клики по канвасу (при остановленной симуляции) инвертируют клетку. -->
        <canvas id="lifeCanvas" class="life-canvas" aria-label="Поле клеточного автомата"></canvas>
      </div>

      <div class="life-footer">
        <div class="muted">Шаг: <span id="stepCounter">0</span> / <span id="tTotal">8</span></div>
        <div class="muted">Размер: <span id="sizeInfo">—</span></div>
      </div>
    </section>

    <!-- БЛОК 1 -->
<section class="section reveal" id="s1">
  <div class="card">
    <h3>Блок 1. Игра «Жизнь» Конвея</h3>

    <p>
      Игра «Жизнь» Конвея — пожалуй, наиболее известный клеточный автомат, да и по совместительству самая популярная его работа.
      Сам Конвей, кстати, был недоволен тем, насколько она известнее других работ, и не слишком любил о ней рассказывать — кроме как
      отдельным интересующимся детям. Но исторически эта известность была неизбежна: «Жизнь», вдохновленная намного более сложным
      автоматом фон Неймана, задумывалась как наиболее простой по набору правил клеточный автомат с нетривиальным поведением.
    </p>

    <p>
      И, надо сказать, у группы энтузиастов во главе с Конвеем получилось выполнить поставленную задачу: правила «Жизни» настолько просты,
      что обычно их формулируют просто как <strong>B3/S23</strong>:
    </p>

    <ol>
      <li>Если сумма соседей — окрестности клетки 3×3 с целевой клеткой в центре — равна двум или трём и клетка жива, она остаётся живой, иначе — умирает.</li>
      <li>Если сумма соседей равна трём и клетка мертва — она становится живой.</li>
    </ol>

    <p>
      Несмотря на это, в игре существует огромное множество различных интересных конфигураций: периодические и двигающиеся фигуры,
      ружья, паровозы, отражатели и многие другие. Но обратной стороной такой простоты стало существование так называемых
      <em>райских садов</em> — таких конфигураций клеток, у которых не может быть предыдущего поколения $($прообраза$)$.
    </p>

    <p>
      Как говорит история, вскоре Конвей доказал полноту «Жизни» по Тьюрингу, а после этого практически потерял интерес к данной теме.
      А не учился ли он, случаем, на Физтехе?
    </p>

    <p>
      И вот когда смотришь на все эти красивые эволюции паттернов, возникает вполне естественное желание — каким-то образом подобрать
      начальную конфигурацию так, чтобы через заданное число итераций поле «Жизни» приобрело заданный вид.
    </p>

    <p>
      Вследствие устройства «Жизни» эта задача, к сожалению, не имеет простого алгоритмического решения, и остаётся только отправиться
      бороздить науку в поисках подходящего способа что-то всё-таки посчитать. Этим мы и займёмся.
    </p>

    <div class="img-placeholder">место для изображения / иллюстрации эволюции</div>
  </div>
</section>

<!-- БЛОК 2 -->
<!-- БЛОК 2 — точная вставка твоего текста, только с оформленными формулами -->
<section class="section reveal" id="s2">
  <div class="card">
    <h3>Блок 2. Формальная постановка обратной задачи к «Жизни» и SAT.</h3>

    <p>Теперь пора и формализовать поставленную задачу.</p>

    <p>Пусть $Χ_0$ – бинарная матрица $(x_{i,j}$ in {0,1}$)$ – начальный слой, то есть при $t = 0$,</p>
    <p>$X_T$ – целевая бинарная матрица при $t = T$</p>
    <p>Условимся присваивать живым клеткам значение 1, а мертвым — 0</p>

    <p>Правило жизни можно записать как</p>
    <div class="formula-block">
      $$
      x_{i,j,t+1} =
      \begin{cases}
        1, & \text{если } x_{i,j,t} = 1 \text{ и } s \in \{2,3\}, \\\\
        1, & \text{если } x_{i,j,t} = 0 \text{ и } s = 3, \\\\
        0, & \text{иначе.}
      \end{cases}
      $$
    </div>

    <p>Или в логических терминах</p>
    <div class="formula-block">
      $$
      x_{i,j,t+1} \;\leftrightarrow\; \bigl( (x_{i,j,t} \land (s \in \{2,3\})) \;\lor\; (\lnot x_{i,j,t} \land (s = 3)) \bigr).
      $$
    </div>

    <p>С помощью этого правила можно рекуррентно вычислить матрицы слоев для любого $t$.</p>

    <p>Что с этим добром можно сделать?</p>

    <p>
      Можно просто перебрать все варианты полей заданного размера — вполне себе вариант, но сложность растет экспоненциально,
      а никаких оптимизаций предложить не получается. Да еще и для каждого начального слоя придется просчитывать эволюцию
      до времени $T$. В общем, лучше использовать только в крайнем случае.
    </p>

    <p>
      Второй вариант — свести поставленную обратную задачу к «Жизни» к другой NP-полной задаче — задаче выполнимости булевой функции
      $($SAT, Boolean satisfiability problem$)$.  в конъюнктивной нормальной форме $($далее — КНФ$)$. Задача заключается в следующем:
      можно ли назначить всем переменным, встречающимся в формуле, значения ложь и истина так, чтобы формула стала истинной.
      А КНФ — одна из унифицированных $($нормальных$)$ форм записи булевой формулы, в которой формула имеет общий вид конъюнкции клауз —
      подформул, состоящих из дизъюнкций литералов — символов $x$ или $¬x$.
    </p>

    <!-- та самая "формула-иллюстрация КНФ" -->
    <div class="formula-block">
      $$
      F = C_1 \land C_2 \land \dots \land C_m, \qquad
      C_k = (\ell_{k,1} \lor \ell_{k,2} \lor \dots \lor \ell_{k,r_k}),
      $$
      где $\ell_{k,j}$ — либо $x$, либо $\lnot x$.
    </div>

    <p>
      Согласно теореме Кука, задача SAT для булевых формул, записанных в конъюнктивной нормальной форме, является NP-полной.
      И тут нам страшно не повезло — та же задача SAT, но для функций в дизъюнктивной нормальной форме $($ДНФ, почти то же самое,
      что и КНФ, только конъюнкцию и дизъюнкцию поменяли местами$)$ решается за линейное от длины формулы время.
      А мы же вынуждены использовать именно КНФ, в чем нетрудно убедиться: правило «Жизни» для отдельной клетки записывается через дизъюнкцию,
      пусть пока и не литералов, а общее условие для эволюции, очевидно, конъюнкцией всех условий для всех временных слоев.
    </p>

    <!-- та самая "формула-иллюстрация ДНФ" -->
    <div class="formula-block">
      $$
      G = D_1 \lor D_2 \lor \dots \lor D_s, \qquad
      D_\alpha = (x_{i_1} \land x_{i_2} \land \dots \land x_{i_p}),
      $$
      то есть дизъюнкция конъюнкций.
    </div>

    <p>
      Но как свести численные ограничения на сумму соседей к конъюнкции конечного числа клауз? Сразу ничего на ум не приходит, не так ли?
      Но эта проблема занимала не только глупых бмочек, но и, если не великие, то весьма сильные умы прошлого.
      Так что было предложено множество вариантов такого равносильного перехода. Мы рассмотрим один из наиболее понятных —
      Sinz's Sequential counter $($Sinz, 2005$)$. Но для начала вновь формализуем задачу, уж без этого никуда.
    </p>

    <p>
      Назовем линейные неравенства с булевыми переменными $($но тут понимаемыми как обычные целые числа$)$ псевдобулевыми ограничениями,
      а их частный случай при всех коэффициентах, равных единице — кардинальными ограничениями:
    </p>

    <div class="formula-block">
      $$
      \sum_i c_i x_i \le k, \quad x_i \in \{0,1\}
      $$
      — псевдобулево ограничение
      $$
      \sum_{i=1}^n x_i \le k
      $$
      — кардинальное ограничение.
    </div>

    <p>
      Заметим, что нам действительно в определении ограничиться лишь знаком ≤ — при замене $x$ → $¬x$ , которая в терминах псевдобулевых
      неравенств выражается как $x$ → 1 - $x$, тоже получится неравенство вида
    </p>

    <div class="formula-block">
      $$
      \sum_i c_i x_i \le k,
      $$
    </div>

    <p>
      которое умножением на −1 переводится в неравенство относительно $x$ со знаком ≥. А равенство = $k$, вырожденный случай неравенства,
      можно записать, в конце концов, как конъюнкцию условий для ≥ $k$ и ≤ $k$.
    </p>

    <p>
      В нашем случае мы считаем простую сумму всех соседей из окрестности Мура, поэтому нам предстоит работать только с кардинальными
      ограничениями, для которых и разработан метод Sequential counter. Основная идея SC: построить «ленточный счётчик»
      с вспомогательными булевыми переменными, которые несут смысл «на первых $i$ переменных число единиц уже достигло хотя бы $j$».
    </p>

    <p>Вводим вспомогательные переменные $s_{i,j}$ для индексов</p>
    <ul>
      <li>i = 1,…,n−1 (префиксы без последнего элемента),</li>
      <li>j = 1,…,k (ступени счётчика),</li>
    </ul>

    <p>со смыслом:</p>

    <div class="formula-block">
      $$
      s_{i,j} \;\text{означает}\; \Bigl( \sum_{p=1}^i x_p \ge j \Bigr).
      $$
    </div>

    <p>То есть в первых $i$ слагаемых уже набралось хотя бы $j$ единиц.</p>

    <p>
      Чтобы придать вспомогательным переменным этот смысл, мы введем следующий набор аксиом $($R1–R4$)$:
    </p>

    <div class="formula-block">
      $$
      \begin{aligned}
        \text{(R1)} &\quad x_i \Rightarrow s_{i,1} \\
        \text{(R2)} &\quad s_{i-1,j} \Rightarrow s_{i,j} \\
        \text{(R3)} &\quad (x_i \land s_{i-1,j-1}) \Rightarrow s_{i,j} \\
        \text{(R4)} &\quad x_i = 1 \Rightarrow \lnot s_{i-1,k}
      \end{aligned}
      $$
    </div>

    <p>
      $(R1)$ Εсли $x_i = 1$, то в первых $i$ слагаемых уже набралась хотя бы одна единица.
    </p>
    <p>
      $(R2)$ Если в первых $i−1$ слагаемых набралось хотя бы $j$ единиц, то и в первых $i$ слагаемых набралось хотя бы $j$ единиц.
    </p>
    <p>
      $(R3)$ Если в первых $i−1$ слагаемых набралось хотя бы $j−1$ единиц, а $x_i = 1$, то в первых $i$ слагаемых набралось хотя бы j$$ единиц.
    </p>
    <p>
      $(R4)$ Если $x_i = 1$, то на первых $i−1$ слагаемых точно не набралось $k$ единиц, или, эквивалентно, набралось не более $k−1$ единиц.
    </p>

    <p>
      Можно попытаться интуитивно или как-то математически строго убедиться, что эти аксиомы действительно определяют для
      вспомогательных переменных смысл «набралось не менее j единиц». Собирая булеву формулу в КНФ для произвольного
      кардинального ограничения мы через конъюнкцию должны записать все частные подстановки аксиом (имеющие смысл исходя из
      ограничений в самих выражениях аксиом) R1–R4 для всех возможных s$($i,j$)$ $(i = 1, \dots, n, j = 1, \dots, k)$.
    </p>

    <p>Тогда теория гарантирует эквивалентность</p>
    <div class="formula-block">
      $$
      \exists s \;\; \mathrm{SC}(x_1,\dots,x_n,s;k) = 1 \;\;\Longleftrightarrow\;\; \sum_{i=1}^n x_i \le k.
      $$
    </div>

    <p>
      То есть, булева функция в КНФ $SC(x_1, \dots ,x_n,s;k)$ выполнима тогда и только тогда, когда выполнено соответствующее кардинальное
      неравенство. Заметим очень важную деталь, неочевидную при первом прочтении: $SC$, пусть формально записанная как функция
      от (x_1,…,x_n,s;k), в действительности является функцией только от вспомогательных переменных s, так как для каждой
      конкретной задачи $x_1, \dots x_i$ и $k$ – заданные константы. Но это вовсе не означает, что не существует других подстановок,
      «выполняющих» функцию SC, что очень сильно подпортит нам жизнь в дальнейшем. Отличное доказательство эквивалентности
      можно прочитать в авторстве ChatGPT, если захочешь — попроси меня прислать его $($тогда бонусом будут сильно облегчающие
      жизнь поясняющие комментарии$)$.
    </p>

    <p>Также можно убедиться в линейности размеров формулы $SC$ по $k$ и по $n$.</p>

    <p>
      А как все-таки из этого получить условие обратной задачи для «Жизни», ведь нам нужны конкретные $x_1, \dots , x_i$ в формуле,
      а их значения мы знаем лишь для последнего временного слоя $t = T$. Вот для него как раз записываем дополнительные
      конкретизирующие клаузы $x_{i,j,T}$ или $¬x_{i,j,T}$ — в зависимости от значения $x_{i,j}$ в целевой матрице X_T,
      ведь для выполнимости нам нужно, чтобы все клаузы стали равны 1.
    </p>

    <p>
      А дальше — проблема: как связать выполнимость конкретной подформулы $SC(B3)$^$SC(S23)$ для $x_{i,j,t}$ со значением переменной $x_{i,j,t+1}$?
      Да на самом деле просто — через индикаторную переменную $x_{i,j,t+1} \iff b \iff SAT~~~ SC(B3)$^$SC(S23)$ для $x_{i,j,T}$.
      В качестве индикатора можно ввести дополнительную, отсутствовавшую ранее в подформуле $SC$ переменную $s_{n,k+1}$,
      но определяемую по тем же аксиомам. По своему смыслу она будет явно соответствовать как раз таки выполнению
      кардинального ограничения — она и будет взята как индикатор $b$.
    </p>

    <p>
      Но тут мы еще должны вспомнить, что все не так просто: доказанная Sinz`ом теорема говорит лишь о существовании
      подстановки $s$, обращающей $SC$ в единицу, но не говорит ничего о качестве этой подстановки. В действительности, в чем
      мы с ChatGPT убедились на горьком опыте, такая подстановка зачастую не единственна, и возможен набор $s$, не удовлетворяющий
      смыслу, который мы для него пытались задать акисомами R1–R4. Другими словами, эти аксиомы достаточны для выполнения
      кардинального ограничения, но слишком слабы для того, чтобы гарантировать именно желаемый смысл для значений в
      «выполняющей» подстановке $s$. Для этого ее необходимо дополнить и расширить:
    </p>

    <div class="formula-block">
      $$
      s_{i,j} \Rightarrow s_{i-1,j} \lor x_i \quad (\text{для } i \ge 2),
      $$
      $$
      s_{i,j} \Rightarrow s_{i-1,j} \lor s_{i-1,j-1} \quad (\text{для } i \ge 2).
      $$
    </div>

    <p>
      Они задают правила обратного хода: чтобы $s_{i,j}$ была равна единице, теперь у нее должны быть веские основания для этого,
      соответствующие обратным импликациям в акисомах R2–R3.
    </p>

    <p>
      Также необходимо изменить утверждение R4 — теперь это guarded R4:
    </p>

    <div class="formula-block">
      $$
      (\lnot b \lor \lnot x_i \lor \lnot s_{i-1,k}).
      $$
    </div>

    <p>
      Если $b = 1$, правило активируется и запрещает $k+1$-ю единицу; если $b = 0$ — переполнение разрешено, что и нужно для
      эквивалентности $b \iff ∑ ≤ k$.
    </p>

    <p>
      Отмечу также очевидную, но явно не высказанную мысль, что правило жизни есть дизъюнкция двух подформул:
      B3 и S23.
      Как же из нее сделать клаузу, содержащую только литералы и знаки дизъюнкции?
      Тут нам и помогает кусочная запись правила жизни:
    </p>

    <div class="formula-block">
      $$
      \text{IN23} \leftrightarrow (\mathrm{ge2} \land \mathrm{le3}) \quad \text{(при } x_t = 1),
      $$
      $$
      \text{EQ3} \leftrightarrow (\mathrm{ge3} \land \mathrm{le3}) \quad \text{(при } x_t = 0).
      $$
    </div>

    <p>Значит, достаточно записать клаузы</p>
    <div class="formula-block">
      $$
      x_t \land \mathrm{IN23} \rightarrow \mathrm{ge2}, \quad
      x_t \land \mathrm{IN23} \rightarrow \mathrm{le3}, \quad
      x_t \land \mathrm{ge2} \land \mathrm{le3} \rightarrow \mathrm{IN23},
      $$
      $$
      \lnot x_t \land \mathrm{EQ3} \rightarrow \mathrm{ge3}, \quad
      \lnot x_t \land \mathrm{EQ3} \rightarrow \mathrm{le3}, \quad
      \lnot x_t \land \mathrm{ge3} \land \mathrm{le3} \rightarrow \mathrm{EQ3}.
      $$
    </div>

    <p>
      Тут мы представили кусочные эквивалентности как импликации, а затем и сами эквивалентности записали как две импликации.
      А импликация легко выражается через дизъюнкцию и отрицание — то, что нам и нужно для клаузы КНФ.
    </p>

    <p>
      Теперь, собрав поистине огромную формулу, передаем ее в SAT-решатель и ждем, пока он отыщет «выполняющий» набор $x_{i,j,t}.
      Из всего набора нас, конечно, интересует только слой $X_0$ $(x_{i,j,0})$.
      ChatGPT дал примерно такие оценки для размеров итоговой КНФ-формулы:
    </p>

    <div class="formula-block">
      $$
      \#\text{clauses} \approx 512 \cdot N \cdot T + N
      $$
      $$
      \#\text{vars} \approx N \cdot (T+1) + 141 \cdot N \cdot T = N \cdot (1 + 142T)
      $$
      где $N$ – произведение длины и ширины поля.
    </div>

    <p>
      Выходит так, что пусть и довольно неплохо оптимизированный SAT-решатель все равно утонет в размерах функции,
      и для достаточно больших полей $($даже 15x15$)$ и достаточно больших T $($T > 3$)$ дождаться решения проблематично.
      Также стоит вспомнить про райские сады: легко может оказаться, что желаемая целевая конфигурация клеток вообще не имеет прообраза,
      и тогда, получить от решателя ответ UNSAT спустя, может, дни, недели, месяцы ожидания будет очень обидно.
    </p>

    <p>
      Тут можно перейти к близкой, но другой задаче — задаче максимальной выполнимости $($MaxSAT$)$. Всю булеву функцию можно разделить
      на два типа клауз или, шире, подформул — те, для которых нам принципиально важно получить именно такие значения $($например,
      живые на X_T тонкие границы рисунков, чтобы вообще гарантированно получить хоть что-то, напоминающее цель$)$, то есть на которых
      выполнимость обязательна и те, где она только желательна, причем можно ввести веса значимости. Тогда MaxSAT-решатель будет искать
      точные совпадения для клауз первого типа и минимизировать $($не$)$взвешенную ошибку для клауз второго типа. Плюс в том, что после
      отыскания точного решения для обязательных подформул можно в любой момент прервать решение и получить «синицу в руке» —
      локальный минимум на пройденных подстановках.
    </p>

    <p>
      Но, согласись, это какое-то странное натягивание оптимизационной логики на логику оптимизированного, но все еще перебора SAT.
      То есть по времени это будет не сильно лучше, чем строгий SAT, а скорее «безопаснее от разочарований». Почему же нам тогда,
      разочаровавшись в строгом подходе не обратиться полностью к оптимизациии? А мы это и сделаем!
    </p>

    <div class="img-placeholder">место для изображения / схемы SAT → SC → Life</div>
  </div>
</section>


<!-- БЛОК 3 -->
<section class="section reveal" id="s3">
  <div class="card">
    <h3>Блок 3. Оптимизационная парадигма</h3>

    <p>
      Задачу SAT решив до половины,
      <br>
      Я очутился в сумрачном лесу,
      <br>
      Утратив правый путь во тьме долины
    </p>

    <p>
      Опустимся и мы в этот ад для теоретика.
      Концептуальная постановка задачи довольно проста: минимизировать, насколько это возможно, различия между целевой матрицей $X_T$
      и матрицей слоя $T$ эволюции некоторого начального приближения $X_0^{\text{init}}$.
    </p>

    <p>В качестве простой меры различия можно предложить взвешенное расстояние Хэмминга:</p>
    <div class="formula-block">
      $$
      F(X_0) := \sum_{i,j} w_{i,j} \cdot \bigl( x_{i,j,T}(X_0) \oplus \text{target}_{i,j} \bigr).
      $$
    </div>

    <p>
      Далее можно отыскать дискретный аналог производной, но не для бесконечно малого прироста аргумента, а для дискретной смены
      значения какого-то аргумента на противоположное:
    </p>
    <div class="formula-block">
      $$
      \Delta F(p,q; X_0) := F(X_0 \oplus e_{p,q}) - F(X_0),
      $$
      где $e_{p,q}$ — матрица с единицей в $(p,q)$ и нулями вне.
    </div>

    <p>
      Очень важный, но не очевидный без прямого указания факт — <strong>локальность изменения</strong>.
      Действительно, если мы на $X_0$ поменяем состояние одной клетки, это может отразиться только на 8 соседних клетках
      для $X_1$, на 8 соседях для каждой из соседних клеток на $X_2$ и т. д.
      Этот результат обобщается предложенной ChatGPT $($и оставленной без редактирования в дань уважения$)$ Леммой о локальности.
    </p>

    <div class="formula-block">
      <strong>Лемма о локальности $($лемма о «световом конусе»$)$.</strong>
      Значение $x_{i,j,t}$ зависит только от значений слоя $0$ в квадрате Чебышёва радиуса $t$ вокруг $(i,j)$.
    </div>

    <p>
      Это означает, что нет необходимости рассчитывать $\Delta F(p,q; X_0)$ для всех $i,j$ – а только для тех, которые лежат
      в $T$-окрестности $($квадрате $(2T+1) \times (2T+1)$$)$ точки $(p,q)$. Данное замечание сильно упрощает вычисления и ускоряет
      алгоритмы оптимизации.
    </p>

    <p>
      Итак, первый путь — примитивный градиентный спуск, то есть алгоритм идёт в направлении наибольшего уменьшения расстояния $F$.
      В действительности типичная обратная задача для «Жизни» устроена так, что она имеет множество вариантов оптимизационного шага,
      для которых $\Delta F = 0$ или $\Delta F > 0$. Значит, алгоритм градиентного спуска быстро упрётся в локальный минимум.
    </p>

    <p>
      Другой и верный путь — разрешить алгоритму иногда принимать «плохие» шаги с $\Delta F \ge 0$.
      Другими словами, мы приходим к необходимости использования стохастического локального поиска с вероятностным принятием
      ухудшающих шагов.
    </p>

    <p>В общем, сверхразум предложил следующие общеалгоритмические методы:</p>
    <ul>
      <li><strong>Алгоритм имитации отжига $($Simulated Annealing, SA$)$:</strong> допускает иногда ухудшающие шаги с вероятностью, зависящей от «температуры».</li>
      <li><strong>Tabu-поиск:</strong> запрещаем недавно сделанные изменения на фиксированное окно по времени, чтобы не «зациклиться».</li>
      <li><strong>Редкие двойные изменения:</strong> на плато пробуем изменить пару значений из $X_0$ среди небольшого набора.</li>
    </ul>

    <p>
      Применяя эти техники, удаётся построить алгоритм, проходящий большое число итераций, уже задаваемое не выходом на плато,
      а тем или иным пороговым условием. Этот метод и позволил за разумное время получить очень неплохие конфигурации:
    </p>

    <div class="img-placeholder">место для изображения / «до» и «после»</div>

    <p>
      Однако он имеет досадный недостаток: $X_0$ уж очень сильно похож на $X_T$, и поведение клеточного автомата слишком предсказуемо.
      Естественное решение — не ограничиваться «световым конусом», а случайно менять <em>любое</em> значение матрицы $X_0$,
      сохраняя только те, для которых $\Delta F \le 0$.
      Это — и есть тот примитивный эвристический алгоритм, которым была вычислена конфигурация для поздравления.
    </p>

    <p>
      Его основные преимущества — меньшая предсказуемость поведения за счёт случайных изменений всей матрицы, а также возможность
      случайных блужданий на плато, которая с ненулевой вероятностью приведёт алгоритм к выходу с плато.
    </p>
  </div>
</section>

<!-- БЛОК 4 (короткий завершающий, можно убрать или заменить) -->
<section class="section reveal" id="s4">
  <div class="card">
    <h3>Блок 4. Вместо эпилога</h3>
    <p>
      Тут можно перейти к близкой, но другой задаче — задаче максимальной выполнимости (MaxSAT). Всю булеву функцию можно разделить
      на два типа клауз или, шире, подформул — те, для которых нам принципиально важно получить именно такие значения,
      и те, где она только желательна. Тогда MaxSAT-решатель будет искать точные совпадения для клауз первого типа и минимизировать
      (не)взвешенную ошибку для клауз второго типа.
    </p>
    <p>
      Но, согласись, это какое-то странное натягивание оптимизационной логики на логику оптимизированного, но всё ещё перебора SAT.
      То есть по времени это будет не сильно лучше, чем строгий SAT, а скорее «безопаснее от разочарований».
      Почему же нам тогда, разочаровавшись в строгом подходе, не обратиться полностью к оптимизации?
      <strong>А мы это и сделаем.</strong>
    </p>
    <div class="img-placeholder">место для изображения / финальный кадр</div>
  </div>
</section>
</div>
    <!-- Кнопка «Вернуться наверх» -->
<button class="btn back-top" id="backTopBtn" aria-label="Вернуться наверх">▲ Наверх</button>
<script>
  const REPO_IMAGE_URL = "docs/images/mariam_seed.png";
    const MAX_CANVAS_HEIGHT = 700; // чтобы влезало 1300x700

    // запасной X0
    const PRESET_X0 = [
      "00000000000000000000000000000000",
      "00000000000000000000000000000000",
      "00000000000000000000000000000000",
      "00000000000001110000000000000000",
      "00000000000011111000000000000000",
      "00000000000111011100000000000000",
      "00000000001110001110000000000000",
      "00000000011100000111000000000000",
      "00000000111000000011100000000000",
      "00000001111111111111110000000000",
      "00000001111111111111110000000000",
      "00000011100000000000011100000000",
      "00000111000000000000001110000000",
      "00001110000000000000000111000000",
      "00011100000000000000000011100000",
      "00111000000000000000000001110000",
      "01110000000000000000000000111000",
      "11100000000000000000000000011100",
      "00000000000000000000000000000000",
      "00000000000000000000000000000000",
      "00000000000000000000000000000000",
      "00000000000000000000000000000000",
      "00000000000000000000000000000000",
      "00000000000000000000000000000000"
    ];

  let T = 5;
    let DELAY_MS = 750;

    // -------- утилиты --------
    function parseX0(lines){
      const H = lines.length; const W = lines[0].length;
      return Array.from({length: H}, (_, y) =>
        Array.from({length: W}, (_, x) => lines[y].charCodeAt(x) === 49 ? 1 : 0)
      );
    }
    function emptyGrid(H, W){ return Array.from({length: H}, () => Array(W).fill(0)); }
    function neighborCountToroidal(grid, y, x){
      const H = grid.length, W = grid[0].length;
      let s = 0;
      for (let dy = -1; dy <= 1; dy++){
        for (let dx = -1; dx <= 1; dx++){
          if (dx === 0 && dy === 0) continue;
          const yy = (y + dy + H) % H;
          const xx = (x + dx + W) % W;
          s += grid[yy][xx];
        }
      }
      return s;
    }
    function lifeStep(grid){
      const H = grid.length, W = grid[0].length;
      const out = emptyGrid(H, W);
      for (let y = 0; y < H; y++){
        for (let x = 0; x < W; x++){
          const n = neighborCountToroidal(grid, y, x);
          const alive = grid[y][x] === 1;
          out[y][x] = (n === 3 || (alive && n === 2)) ? 1 : 0;
        }
      }
      return out;
    }

    // -------- canvas + масштаб --------
    const canvas = document.getElementById('lifeCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const COLOR_BG   = '#FFFFFF';
    const COLOR_GRID = 'rgba(152,118,142,0.18)';
    const COLOR_ALIVE= '#281E30';

    function getCellSize(H, W){
      const wrap = canvas.parentElement;
      const availW = Math.floor(wrap.clientWidth);
      const cellByW = availW / W;
      const cellByH = MAX_CANVAS_HEIGHT / H;
      return Math.min(cellByW, cellByH);
    }

    function resizeCanvasToContainer(H, W){
      const cell = getCellSize(H, W);
      const cw = cell * W;
      const ch = cell * H;
      canvas.width = cw;
      canvas.height = ch;
      canvas.style.width = cw + "px";
      canvas.style.height = ch + "px";
      return cell;
    }

    function drawGrid(grid){
      const H = grid.length, W = grid[0].length;
      const cell = canvas.width / W; // всегда вычисляем из фактической ширины
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = COLOR_ALIVE;
      for (let y = 0; y < H; y++){
        for (let x = 0; x < W; x++){
          if (grid[y][x]){
            ctx.fillRect(x*cell, y*cell, cell, cell);
          }
        }
      }

      ctx.strokeStyle = COLOR_GRID;
      ctx.lineWidth = 1;
      for (let x = 0; x <= W; x++){
        const X = x*cell + 0.5;
        ctx.beginPath(); ctx.moveTo(X, 0); ctx.lineTo(X, H*cell); ctx.stroke();
      }
      for (let y = 0; y <= H; y++){
        const Y = y*cell + 0.5;
        ctx.beginPath(); ctx.moveTo(0, Y); ctx.lineTo(W*cell, Y); ctx.stroke();
      }
    }

    // -------- загрузка картинки --------
    function loadImageFromUrl(url){
      return new Promise((resolve, reject) => {
        const img = new Image();
        // для GitHub Pages (один и тот же origin) можно без crossOrigin
        img.onload = () => resolve(img);
        img.onerror = (e) => reject(e || new Error('image load error'));
        img.src = url + '?_=' + Date.now();
      });
    }

    async function imageToGridNoResize(img){
      const w = img.naturalWidth;
      const h = img.naturalHeight;
      const off = document.createElement('canvas');
      off.width = w;
      off.height = h;
      const offCtx = off.getContext('2d');
      offCtx.drawImage(img, 0, 0, w, h);
      let imgData;
      try {
        imgData = offCtx.getImageData(0, 0, w, h);
      } catch (e){
        console.warn('[init] getImageData провалился, вероятно CORS → fallback:', e);
        return null;
      }
      const data = imgData.data;
      const grid = [];
      const THRESHOLD = 128;
      for (let y = 0; y < h; y++){
        const row = [];
        for (let x = 0; x < w; x++){
          const i = (y*w + x)*4;
          const r = data[i], g = data[i+1], b = data[i+2];
          const lum = 0.299*r + 0.587*g + 0.114*b;
          row.push(lum < THRESHOLD ? 1 : 0);
        }
        grid.push(row);
      }
      return grid;
    }

    async function initGridFromImageOrFallback(){
      try {
        const img = await loadImageFromUrl(REPO_IMAGE_URL);
        const g = await imageToGridNoResize(img);
        if (g && g.length && g[0] && g[0].length){
          console.log('[init] конфигурация из картинки:', g[0].length + 'x' + g.length);
          return g;
        }
        console.warn('[init] картинка есть, но не получилось прочитать → fallback');
        return parseX0(PRESET_X0);
      } catch (err){
        console.warn('[init] не удалось загрузить картинку, fallback:', err);
        return parseX0(PRESET_X0);
      }
    }

    // -------- симулятор --------
    let grid = parseX0(PRESET_X0);
    let tGoal = T;
    let step = 0;
    let isRunning = false;
    let timerId = null;

    function syncInfo(){
      document.getElementById('tTotal').textContent = String(tGoal);
      document.getElementById('stepCounter').textContent = String(step);
      document.getElementById('sizeInfo').textContent = grid[0].length + ' × ' + grid.length;
    }

    function start(){
      if (isRunning) return;
      isRunning = true;
      updateToggleUI();
      const tInput = document.getElementById('tInput');
      const delayInput = document.getElementById('delayInput');
      tGoal = Math.max(1, parseInt(tInput?.value || '8', 10));
      const delay = Math.max(50, parseInt(delayInput?.value || String(DELAY_MS), 10));
      tick(delay);
    }

    function tick(delay){
      if (step >= tGoal){
        isRunning = false;
        timerId = null;
        updateToggleUI();
        return;
      }
      timerId = setTimeout(() => {
        grid = lifeStep(grid);
        step++;
        syncInfo();
        drawGrid(grid);
        if (isRunning) tick(delay);
      }, delay);
    }

    function pause(){
      isRunning = false;
      if (timerId){
        clearTimeout(timerId);
        timerId = null;
      }
      updateToggleUI();
    }

    async function reset(){
      pause();
      step = 0;
      grid = await initGridFromImageOrFallback();
      resizeCanvasToContainer(grid.length, grid[0].length);
      syncInfo();
      drawGrid(grid);
      updateToggleUI();
    }

    // -------- кнопки --------
    const toggleBtn = document.getElementById('toggleBtn');
    function updateToggleUI(){
      if (isRunning){
        toggleBtn.textContent = 'Пауза';
        toggleBtn.setAttribute('aria-pressed','true');
      } else {
        toggleBtn.textContent = 'Старт';
        toggleBtn.setAttribute('aria-pressed','false');
      }
    }
    toggleBtn.addEventListener('click', () => { if (isRunning) pause(); else start(); });
    document.getElementById('resetBtn').addEventListener('click', () => { reset(); });

    const moreBtn = document.getElementById('moreBtn');
    const settingsPanel = document.getElementById('settingsPanel');
    let settingsOpen = false;
    moreBtn.addEventListener('click', () => {
      settingsOpen = !settingsOpen;
      settingsPanel.classList.toggle('open', settingsOpen);
      settingsPanel.setAttribute('aria-hidden', String(!settingsOpen));
      moreBtn.textContent = settingsOpen ? 'Скрыть настройки' : 'Доп. настройки';
    });

    // клик по канвасу — инверсия клетки
    canvas.addEventListener('click', (ev) => {
      if (isRunning) return;
      const rect = canvas.getBoundingClientRect();
      const H = grid.length, W = grid[0].length;
      const cell = canvas.width / W;
      const x = Math.floor((ev.clientX - rect.left) / cell);
      const y = Math.floor((ev.clientY - rect.top) / cell);
      if (x >= 0 && x < W && y >= 0 && y < H){
        grid[y][x] ^= 1;
        drawGrid(grid);
      }
    });

    // ресайз окна
    window.addEventListener('resize', () => {
      resizeCanvasToContainer(grid.length, grid[0].length);
      drawGrid(grid);
    });

    // кнопка наверх
    const backTop = document.getElementById('backTopBtn');
    backTop.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));
    window.addEventListener('scroll', () => {
      backTop.classList.toggle('show', window.scrollY > 400);
    });

    // появление секций
    const observer = new IntersectionObserver((entries) => {
      for (const e of entries){
        if (e.isIntersecting){
          e.target.classList.add('revealed');
          observer.unobserve(e.target);
        }
      }
    }, { rootMargin: '0px 0px -10% 0px', threshold: 0.05 });
    document.querySelectorAll('.reveal').forEach(el => observer.observe(el));

    // старт
    (async function init(){
      grid = await initGridFromImageOrFallback();
      resizeCanvasToContainer(grid.length, grid[0].length);
      syncInfo();
      drawGrid(grid);
      updateToggleUI();
    })();
  </script>
  
</body>
</html>
